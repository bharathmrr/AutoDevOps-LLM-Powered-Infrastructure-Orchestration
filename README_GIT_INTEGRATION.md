# Git Integration in AutoDevOps

AutoDevOps includes built-in Git version control integration that automatically commits each generated infrastructure file with descriptive commit messages.

## Features

### ðŸ”„ Automatic Commits
Every generated infrastructure file is automatically committed to Git with:
- **Descriptive commit messages** including the file name and generator type
- **Metadata** about the user request, IaC type, provider, and action
- **Timestamp** for audit trail
- **Author information** (configurable)

### ðŸ“ Commit Message Format

```
Generate main.tf

Generated by AutoDevOps TerraformGenerator

Configuration:
  user_request: Create an EC2 instance with t3.micro on AWS
  iac_type: terraform
  provider: aws
  action: create
```

### ðŸ” Audit Trail
- Complete history of all infrastructure changes
- File-specific commit history
- Diff tracking for changes
- Tag support for releases

## Usage

### Basic Setup

```python
from audit.version_control import GitVersionControl
from generators.terraform import TerraformGenerator

# Initialize Git integration
git = GitVersionControl(
    repo_path="./infrastructure",
    auto_commit=True,
    user_name="AutoDevOps Bot",
    user_email="bot@autodevops.io"
)

# Create generator with Git integration
generator = TerraformGenerator(
    output_dir="./infrastructure/terraform",
    git_integration=git,
    auto_commit=True
)

# Generate and save (automatically commits)
code = generator.generate(intent, parameters)
file_path = generator.save_to_file(
    code=code,
    filename="main.tf",
    commit_metadata={
        "user_request": "Create EC2 instance",
        "iac_type": "terraform",
        "provider": "aws"
    }
)
```

### Configuration

Configure Git integration via environment variables in `.env`:

```bash
# Git Configuration
GIT_ENABLED=true
GIT_REPO_PATH=./infrastructure
GIT_AUTO_COMMIT=true
GIT_USER_NAME=AutoDevOps Bot
GIT_USER_EMAIL=bot@autodevops.io
```

### Manual Git Operations

```python
# Commit a specific file
git.commit_file(
    file_path="terraform/main.tf",
    message="Update EC2 instance configuration"
)

# Commit multiple files
git.commit_multiple_files(
    file_paths=["terraform/main.tf", "terraform/variables.tf"],
    message="Update Terraform configuration"
)

# Get commit history
history = git.get_file_history("terraform/main.tf", max_count=10)
for commit in history:
    print(f"{commit['short_sha']} - {commit['message']}")

# Check for uncommitted changes
if git.has_uncommitted_changes():
    print("There are uncommitted changes")
    print(git.get_diff())

# Create a tag
git.create_tag("v1.0.0", message="Production release")

# Get latest commit
latest = git.get_latest_commit()
print(f"Latest: {latest['short_sha']} by {latest['author']}")
```

## Architecture

### GitVersionControl Class

Located in `src/audit/version_control.py`, this class provides:

- **Repository initialization**: Automatically creates or opens Git repository
- **Auto-commit**: Commits files when saved by generators
- **History tracking**: Retrieves commit history for files
- **Diff support**: Shows uncommitted changes
- **Tag management**: Create and list tags

### Integration with Generators

All generators inherit from `BaseGenerator` which includes:

```python
def save_to_file(
    self,
    code: str,
    filename: str,
    subdirectory: Optional[str] = None,
    commit_metadata: Optional[Dict[str, Any]] = None
) -> Path:
    # Save file
    # Auto-commit if enabled
    if self.auto_commit and self.git_integration:
        self.git_integration.commit_file(...)
```

## Benefits

### 1. **Full Auditability**
Every infrastructure change is tracked with:
- Who made the change (user/system)
- When it was made (timestamp)
- What was changed (file content)
- Why it was changed (user request in metadata)

### 2. **Rollback Capability**
```bash
# View history
cd infrastructure
git log

# Rollback to previous version
git checkout <commit-hash> main.tf

# Create a new branch for testing
git checkout -b test-changes
```

### 3. **Compliance**
- Meets regulatory requirements for change tracking
- Provides complete audit trail
- Supports compliance frameworks (SOC2, HIPAA, etc.)

### 4. **Collaboration**
- Multiple users can work on infrastructure
- Changes are tracked per user
- Easy to review and merge changes

### 5. **Disaster Recovery**
- Complete history of infrastructure state
- Easy to restore previous configurations
- Tagged releases for production deployments

## Example Workflow

1. **User Request**: "Create a load-balanced web application on AWS"

2. **AutoDevOps Generates**:
   - `terraform/main.tf` (EC2, ALB, ASG)
   - `terraform/variables.tf` (Input variables)
   - `terraform/outputs.tf` (Output values)

3. **Auto-Commit**: Each file is committed separately:
   ```
   commit 1: Generate main.tf
   commit 2: Generate variables.tf
   commit 3: Generate outputs.tf
   ```

4. **Review**: User reviews the generated code:
   ```bash
   cd infrastructure
   git log --oneline
   git show <commit-hash>
   ```

5. **Apply**: User applies the infrastructure:
   ```bash
   terraform init
   terraform plan
   terraform apply
   ```

6. **Tag Release**: Mark this as a release:
   ```python
   git.create_tag("v1.0.0", message="Initial production deployment")
   ```

## Demo

Run the demo script to see Git integration in action:

```bash
python examples/git_integration_demo.py
```

This will:
1. Initialize a Git repository
2. Generate Terraform and Kubernetes files
3. Auto-commit each file
4. Show commit history
5. Display file-specific history

## Troubleshooting

### Git Not Available

If GitPython is not installed:
```bash
pip install gitpython
```

### Permission Issues

Ensure the user has write permissions to the infrastructure directory:
```bash
chmod -R u+w ./infrastructure
```

### Commit Conflicts

If there are uncommitted changes:
```python
# Check status
if git.has_uncommitted_changes():
    # View changes
    print(git.get_diff())
    
    # Commit manually
    git.commit_multiple_files(
        file_paths=[...],
        message="Manual commit of pending changes"
    )
```

## Best Practices

1. **Use Descriptive Metadata**: Include relevant information in commit metadata
2. **Tag Releases**: Create tags for production deployments
3. **Review Before Apply**: Always review generated code before applying
4. **Regular Backups**: Push to remote repository regularly
5. **Branch Strategy**: Use branches for testing changes

## Remote Repository

To push to a remote repository:

```bash
cd infrastructure
git remote add origin <your-repo-url>
git push -u origin main
```

Configure in `.env`:
```bash
GIT_REMOTE_URL=https://github.com/your-org/infrastructure.git
GIT_AUTO_PUSH=true
```

## Security

- **Secrets**: Never commit secrets or credentials
- **`.gitignore`**: Properly configured to exclude sensitive files
- **Access Control**: Use repository permissions to control access
- **Encryption**: Consider using git-crypt for sensitive data

## Summary

AutoDevOps Git integration provides:
- âœ… Automatic version control for all generated files
- âœ… Complete audit trail with metadata
- âœ… Easy rollback and disaster recovery
- âœ… Compliance and regulatory support
- âœ… Collaboration and review workflows
- âœ… Production-ready infrastructure management
