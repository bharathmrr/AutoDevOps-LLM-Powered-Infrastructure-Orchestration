"""Base class for all IaC generators"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from pathlib import Path
from loguru import logger


class BaseGenerator(ABC):
    """Abstract base class for Infrastructure-as-Code generators"""
    
    def __init__(
        self,
        output_dir: str = "./infrastructure",
        git_integration: Optional[Any] = None,
        auto_commit: bool = True
    ):
        """Initialize generator
        
        Args:
            output_dir: Directory to save generated files
            git_integration: GitVersionControl instance
            auto_commit: Automatically commit generated files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.git_integration = git_integration
        self.auto_commit = auto_commit
        
        logger.info(f"{self.__class__.__name__} initialized with output dir: {output_dir}")
    
    @abstractmethod
    def generate(
        self,
        intent: Dict[str, Any],
        parameters: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate Infrastructure-as-Code
        
        Args:
            intent: Parsed user intent
            parameters: Extracted parameters
            context: Additional context
            
        Returns:
            Generated IaC code
        """
        pass
    
    @abstractmethod
    def get_file_extension(self) -> str:
        """Get file extension for this IaC type
        
        Returns:
            File extension (e.g., '.tf', '.yaml')
        """
        pass
    
    def save_to_file(
        self,
        code: str,
        filename: str,
        subdirectory: Optional[str] = None,
        commit_metadata: Optional[Dict[str, Any]] = None
    ) -> Path:
        """Save generated code to file and optionally commit to Git
        
        Args:
            code: Generated code
            filename: Output filename
            subdirectory: Optional subdirectory
            commit_metadata: Metadata for Git commit
            
        Returns:
            Path to saved file
        """
        if subdirectory:
            output_path = self.output_dir / subdirectory
            output_path.mkdir(parents=True, exist_ok=True)
        else:
            output_path = self.output_dir
        
        file_path = output_path / filename
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"Saved generated code to: {file_path}")
        
        # Auto-commit to Git if enabled
        if self.auto_commit and self.git_integration:
            try:
                commit_message = self._generate_commit_message(filename, commit_metadata)
                self.git_integration.commit_file(
                    str(file_path),
                    message=commit_message,
                    metadata=commit_metadata
                )
                logger.info(f"Committed file to Git: {filename}")
            except Exception as e:
                logger.warning(f"Failed to commit file to Git: {e}")
        
        return file_path
    
    def _generate_commit_message(
        self,
        filename: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate Git commit message
        
        Args:
            filename: Name of the file
            metadata: Additional metadata
            
        Returns:
            Commit message
        """
        message = f"Generate {filename}\n\n"
        message += f"Generated by AutoDevOps {self.__class__.__name__}\n"
        
        if metadata:
            message += "\nConfiguration:\n"
            for key, value in metadata.items():
                if isinstance(value, dict):
                    message += f"  {key}:\n"
                    for k, v in value.items():
                        message += f"    {k}: {v}\n"
                else:
                    message += f"  {key}: {value}\n"
        
        return message
    
    def format_code(self, code: str) -> str:
        """Format generated code (can be overridden by subclasses)
        
        Args:
            code: Raw generated code
            
        Returns:
            Formatted code
        """
        return code.strip()
    
    def add_header(self, code: str, description: Optional[str] = None) -> str:
        """Add header comment to generated code
        
        Args:
            code: Generated code
            description: Optional description
            
        Returns:
            Code with header
        """
        header_lines = [
            "# Generated by AutoDevOps",
            "# AI-Powered Infrastructure Orchestration",
        ]
        
        if description:
            header_lines.append(f"# Description: {description}")
        
        header_lines.append("")
        
        header = "\n".join(header_lines)
        return f"{header}\n{code}"
    
    def validate_parameters(self, parameters: Dict[str, Any]) -> List[str]:
        """Validate parameters for this generator
        
        Args:
            parameters: Parameters to validate
            
        Returns:
            List of validation errors (empty if valid)
        """
        errors = []
        
        # Subclasses can override to add specific validation
        
        return errors
    
    def get_template(self, template_name: str) -> Optional[str]:
        """Get a code template
        
        Args:
            template_name: Name of the template
            
        Returns:
            Template string or None
        """
        # Subclasses can implement template loading
        return None
    
    def merge_with_existing(
        self,
        new_code: str,
        existing_file: Path
    ) -> str:
        """Merge new code with existing file
        
        Args:
            new_code: Newly generated code
            existing_file: Path to existing file
            
        Returns:
            Merged code
        """
        if not existing_file.exists():
            return new_code
        
        try:
            with open(existing_file, 'r', encoding='utf-8') as f:
                existing_code = f.read()
            
            # Simple merge - subclasses can implement smarter merging
            return f"{existing_code}\n\n{new_code}"
        
        except Exception as e:
            logger.error(f"Error merging with existing file: {e}")
            return new_code
