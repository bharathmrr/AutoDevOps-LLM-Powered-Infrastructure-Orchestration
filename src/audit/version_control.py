"""Git integration for version control"""

import os
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
from loguru import logger

try:
    from git import Repo, GitCommandError
    GIT_AVAILABLE = True
except ImportError:
    GIT_AVAILABLE = False
    logger.warning("GitPython not available - Git integration disabled")


class GitVersionControl:
    """Git version control integration for infrastructure code"""
    
    def __init__(
        self,
        repo_path: str = "./infrastructure",
        auto_commit: bool = True,
        user_name: str = "AutoDevOps Bot",
        user_email: str = "bot@autodevops.io"
    ):
        """Initialize Git version control
        
        Args:
            repo_path: Path to Git repository
            auto_commit: Automatically commit changes
            user_name: Git user name
            user_email: Git user email
        """
        self.repo_path = Path(repo_path)
        self.auto_commit = auto_commit
        self.user_name = user_name
        self.user_email = user_email
        self.repo = None
        
        if not GIT_AVAILABLE:
            logger.warning("Git integration disabled - GitPython not installed")
            return
        
        self._initialize_repo()
    
    def _initialize_repo(self):
        """Initialize or open Git repository"""
        if not GIT_AVAILABLE:
            return
        
        try:
            # Create directory if it doesn't exist
            self.repo_path.mkdir(parents=True, exist_ok=True)
            
            # Check if repo exists
            if (self.repo_path / ".git").exists():
                self.repo = Repo(self.repo_path)
                logger.info(f"Opened existing Git repository at {self.repo_path}")
            else:
                # Initialize new repo
                self.repo = Repo.init(self.repo_path)
                logger.info(f"Initialized new Git repository at {self.repo_path}")
                
                # Create initial commit
                self._create_initial_commit()
            
            # Configure user
            with self.repo.config_writer() as config:
                config.set_value("user", "name", self.user_name)
                config.set_value("user", "email", self.user_email)
        
        except Exception as e:
            logger.error(f"Error initializing Git repository: {e}")
            self.repo = None
    
    def _create_initial_commit(self):
        """Create initial commit with README"""
        try:
            readme_path = self.repo_path / "README.md"
            if not readme_path.exists():
                readme_content = """# Infrastructure as Code

This repository contains infrastructure code generated by AutoDevOps.

## Generated Files

All files in this repository are automatically generated and version controlled.

## Usage

Review the generated code before applying to your infrastructure.
"""
                readme_path.write_text(readme_content)
            
            self.repo.index.add(["README.md"])
            self.repo.index.commit("Initial commit - AutoDevOps infrastructure repository")
            logger.info("Created initial commit")
        
        except Exception as e:
            logger.error(f"Error creating initial commit: {e}")
    
    def commit_file(
        self,
        file_path: str,
        message: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> bool:
        """Commit a file to Git
        
        Args:
            file_path: Path to file (relative to repo)
            message: Commit message
            metadata: Additional metadata for commit message
            
        Returns:
            True if commit successful
        """
        if not GIT_AVAILABLE or not self.repo:
            logger.warning("Git not available - skipping commit")
            return False
        
        try:
            # Convert to relative path
            full_path = Path(file_path)
            if full_path.is_absolute():
                try:
                    relative_path = full_path.relative_to(self.repo_path)
                except ValueError:
                    logger.error(f"File {file_path} is not in repository path")
                    return False
            else:
                relative_path = full_path
            
            # Check if file exists
            file_full_path = self.repo_path / relative_path
            if not file_full_path.exists():
                logger.error(f"File not found: {file_full_path}")
                return False
            
            # Generate commit message
            if not message:
                message = self._generate_commit_message(relative_path, metadata)
            
            # Add file to staging
            self.repo.index.add([str(relative_path)])
            
            # Commit
            commit = self.repo.index.commit(message)
            
            logger.info(f"Committed file: {relative_path} (commit: {commit.hexsha[:7]})")
            return True
        
        except GitCommandError as e:
            logger.error(f"Git command error: {e}")
            return False
        except Exception as e:
            logger.error(f"Error committing file: {e}")
            return False
    
    def commit_multiple_files(
        self,
        file_paths: List[str],
        message: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> bool:
        """Commit multiple files to Git
        
        Args:
            file_paths: List of file paths
            message: Commit message
            metadata: Additional metadata
            
        Returns:
            True if commit successful
        """
        if not GIT_AVAILABLE or not self.repo:
            logger.warning("Git not available - skipping commit")
            return False
        
        try:
            relative_paths = []
            
            for file_path in file_paths:
                full_path = Path(file_path)
                if full_path.is_absolute():
                    try:
                        relative_path = full_path.relative_to(self.repo_path)
                    except ValueError:
                        logger.warning(f"Skipping file not in repo: {file_path}")
                        continue
                else:
                    relative_path = full_path
                
                file_full_path = self.repo_path / relative_path
                if file_full_path.exists():
                    relative_paths.append(str(relative_path))
            
            if not relative_paths:
                logger.warning("No valid files to commit")
                return False
            
            # Generate commit message
            if not message:
                message = f"Add/Update {len(relative_paths)} infrastructure files\n\n"
                message += "Files:\n"
                for path in relative_paths[:10]:  # Limit to first 10
                    message += f"  - {path}\n"
                if len(relative_paths) > 10:
                    message += f"  ... and {len(relative_paths) - 10} more\n"
                
                if metadata:
                    message += f"\nMetadata: {metadata}"
            
            # Add files to staging
            self.repo.index.add(relative_paths)
            
            # Commit
            commit = self.repo.index.commit(message)
            
            logger.info(f"Committed {len(relative_paths)} files (commit: {commit.hexsha[:7]})")
            return True
        
        except Exception as e:
            logger.error(f"Error committing multiple files: {e}")
            return False
    
    def _generate_commit_message(
        self,
        file_path: Path,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate descriptive commit message
        
        Args:
            file_path: Path to file
            metadata: Additional metadata
            
        Returns:
            Commit message
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Determine action
        try:
            # Check if file is new or modified
            if str(file_path) in self.repo.untracked_files:
                action = "Add"
            else:
                action = "Update"
        except:
            action = "Add/Update"
        
        message = f"{action} {file_path.name}\n\n"
        message += f"Generated by AutoDevOps at {timestamp}\n"
        message += f"File: {file_path}\n"
        
        if metadata:
            message += "\nMetadata:\n"
            for key, value in metadata.items():
                message += f"  {key}: {value}\n"
        
        return message
    
    def get_file_history(self, file_path: str, max_count: int = 10) -> List[Dict[str, Any]]:
        """Get commit history for a file
        
        Args:
            file_path: Path to file
            max_count: Maximum number of commits to return
            
        Returns:
            List of commit information
        """
        if not GIT_AVAILABLE or not self.repo:
            return []
        
        try:
            commits = list(self.repo.iter_commits(paths=file_path, max_count=max_count))
            
            history = []
            for commit in commits:
                history.append({
                    "sha": commit.hexsha,
                    "short_sha": commit.hexsha[:7],
                    "author": str(commit.author),
                    "email": commit.author.email,
                    "date": datetime.fromtimestamp(commit.committed_date).isoformat(),
                    "message": commit.message.strip(),
                    "files_changed": len(commit.stats.files)
                })
            
            return history
        
        except Exception as e:
            logger.error(f"Error getting file history: {e}")
            return []
    
    def get_latest_commit(self) -> Optional[Dict[str, Any]]:
        """Get latest commit information
        
        Returns:
            Latest commit info or None
        """
        if not GIT_AVAILABLE or not self.repo:
            return None
        
        try:
            commit = self.repo.head.commit
            return {
                "sha": commit.hexsha,
                "short_sha": commit.hexsha[:7],
                "author": str(commit.author),
                "email": commit.author.email,
                "date": datetime.fromtimestamp(commit.committed_date).isoformat(),
                "message": commit.message.strip()
            }
        except Exception as e:
            logger.error(f"Error getting latest commit: {e}")
            return None
    
    def get_diff(self, file_path: Optional[str] = None) -> str:
        """Get diff of uncommitted changes
        
        Args:
            file_path: Optional specific file path
            
        Returns:
            Diff string
        """
        if not GIT_AVAILABLE or not self.repo:
            return ""
        
        try:
            if file_path:
                diff = self.repo.git.diff(file_path)
            else:
                diff = self.repo.git.diff()
            
            return diff
        except Exception as e:
            logger.error(f"Error getting diff: {e}")
            return ""
    
    def has_uncommitted_changes(self) -> bool:
        """Check if there are uncommitted changes
        
        Returns:
            True if there are uncommitted changes
        """
        if not GIT_AVAILABLE or not self.repo:
            return False
        
        try:
            return self.repo.is_dirty() or len(self.repo.untracked_files) > 0
        except Exception as e:
            logger.error(f"Error checking uncommitted changes: {e}")
            return False
    
    def create_tag(self, tag_name: str, message: Optional[str] = None) -> bool:
        """Create a Git tag
        
        Args:
            tag_name: Name of the tag
            message: Optional tag message
            
        Returns:
            True if tag created successfully
        """
        if not GIT_AVAILABLE or not self.repo:
            return False
        
        try:
            if message:
                self.repo.create_tag(tag_name, message=message)
            else:
                self.repo.create_tag(tag_name)
            
            logger.info(f"Created tag: {tag_name}")
            return True
        except Exception as e:
            logger.error(f"Error creating tag: {e}")
            return False
    
    def get_tags(self) -> List[str]:
        """Get list of tags
        
        Returns:
            List of tag names
        """
        if not GIT_AVAILABLE or not self.repo:
            return []
        
        try:
            return [str(tag) for tag in self.repo.tags]
        except Exception as e:
            logger.error(f"Error getting tags: {e}")
            return []
